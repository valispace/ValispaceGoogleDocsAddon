<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>
	var types = {
		workspaces:{name:'workspaces',
								url: '',
							  data:'workspacesData'},
		projects:{name:'projects',
								url: '',
							  data:'projectsData'},
		requirements:{name:'requirements',
								url: 'project/%<project>%/specifications/%<specification>%/requirements/%<id>%',
							  data:'requirementsData',
							  properties:["identifier","title","text","parents","children","section","images","files"]},
		specifications:{name:'specifications',
								url: 'project/%<project>%/specifications/%<id>%/requirements',
							  data:'specificationsData',
							  properties:["Name", "Description", "Owner"]},
		labels:{name:'labels',
								url: 'project/%<project>%/specifications/groups/%<id>%/requirements',
							  data:'labelsData'},
		groups:{name:'groups',
								url: 'project/%<project>%/specifications/requirements/groups/%<id>%/requirements',
							  data:'groupsData',
							  properties:["Name", "Description", "Owner"]},
		users:{name:'users',
								url: '',
							  data:'usersData'},
		user_groups:{name:'user_groups',
								url: '',
							  data:'user_groupsData'},
		tags:{name:'tags',
								url: '',
							  data:'tagsData'},
		files:{name:'files',
								url: '',
							  data:'filesData'}
	}
	var expandIcon = '<i class="expand_icon fas fa-caret-right"></i>'
	var folderIcon = '<i class="tree_icon fas fa-folder"></i>'
	var specificationIcon = '<i class="tree_icon fas fa-clipboard-check"></i>'
	var reqIcon = '<i class="tree_icon far fa-file-alt"></i>'
	var sectionIcon = '<i class="tree_icon fas fa-list-ul"></i>'
	var plusIcon = '<i class="add-element fas fa-plus-circle"></i>'
	var propertiesIcon = '<i class="show-properties fas fa-ellipsis-v"></i>'
	// var childAddIcon = '<i class="add-element fas fa-plus"></i>' // 

	$(function () {
		$('#search-specific-requirement').click(searchSpecificRequirement);
	});

	function updateAllReferences() {
		// TODO: The function inside update_all_values doesn't return anything, so it is not waiting to finish and the updating-status is modified instantly.
		console.log('clicked on update');
		document.getElementById("updating-status").innerHTML = 'Updating All References...';
		// TODO: Try checking INput to download only the necessary data; Maybe do it on google script
		var specifications = JSON.parse(document.getElementById(types.specifications.data).getAttribute('data'));
		var labels = JSON.parse(document.getElementById(types.labels.data).getAttribute('data'));
		var requirements = JSON.parse(document.getElementById(types.requirements.data).getAttribute('data'));
		var groups = JSON.parse(document.getElementById(types.groups.data).getAttribute('data'));
		var tags = JSON.parse(document.getElementById(types.tags.data).getAttribute('data'));
		var files = JSON.parse(document.getElementById(types.files.data).getAttribute('data'));
		var all_data = {
			specifications,
			labels,
			requirements,
			groups,
			tags,
			files
		}
		google.script.run
			.withSuccessHandler(document.getElementById("updating-status").innerHTML = '')
			.update_all_values(all_data)
	}

	function searchSpecificRequirement() {
		google.script.run.openSearchRequirementDialog()
	}


	/* When the user clicks on the button,
toggle between hiding and showing the dropdown content */
	function expandRequirementTree() {
		if (!document.getElementById("myDropdown").classList.contains('show')) {
			document.getElementById("updating-status").innerHTML = 'Building Tree...';
			buildRequirementsTree_browser();
			getRequirements();
			addTreeListener()
			document.getElementById("updating-status").innerHTML = '';
			document.getElementById("myDropdown").classList.add("show");
		} else {
			document.getElementById("myDropdown").classList.remove("show");
		}
	}

	function buildTreeOnProjectSelect() {
		document.getElementById("updating-status").innerHTML = 'Building Tree...';
		buildRequirementsTree_browser();
		getRequirements();
		addTreeListener()
		document.getElementById("updating-status").innerHTML = '';
	}

	function expandObjectChildren(objectId) {
		document.getElementById(objectId).classList.toggle("show");
	}

	function toggleObjectProperties(objectId) {
		if (document.contains(document.getElementById(objectId+ '_properties'))) {
      document.getElementById(objectId+ '_properties').remove();
		} else {
			var subhtml = ''
			var parent = objectId.split("_");
			var parentType = parent[0].toString();
			var parentId = parseInt(parent[1]);
			subhtml = subhtml.concat('<ul id="',objectId, '_properties" class="dropdown-content show">');

			function capitalizeFirstLetter(string) {
				return string.charAt(0).toUpperCase() + string.slice(1);
			}

			// TODO: Automatically get allowable properties;
			for(property of types[parentType].properties){
				subhtml = subhtml.concat('<li class="property" id="', objectId, '_property_', property,'">', capitalizeFirstLetter(property),'</a>');
			}
			subhtml = subhtml.concat('</ul>');
			document.getElementById(objectId).insertAdjacentHTML('beforeend', subhtml);
			var properties = document.getElementById(objectId).getElementsByClassName("property");
			for (i = 0; i < properties.length; i++) {
				properties[i].addEventListener("click", function () {
					document.getElementById("updating-status").innerHTML = 'Inserting Element';
					htmlElementId = this.id.split('_property_');
					reqName = htmlElementId[0];
					var req = reqName.split("_");
					var reqType = parent[0].toString();
					var reqId = parseInt(parent[1]);
					propertyName = htmlElementId[1];
					console.log(reqId, propertyName);
					var data = JSON.parse(document.getElementById(types[reqType].data).getAttribute('data'));
					google.script.run.withFailureHandler(errorMessage).direct_insert(data, reqName, propertyName);
				});
			}
		}
	}

	// Rename and Repurpose
	// IN this function the real Requirement Tree will be called and html generated
	// function replaceRequirementsTreeHtml() {
	// 	document.getElementById("updating-status").innerHTML = 'Updating Tree...';
	// 	google.script.run.withSuccessHandler(function (htmlToWrite) {
	// 		document.getElementById('requirementTreeInsertButton').innerHTML = htmlToWrite;
	// 		addTreeListener()
	// 		document.getElementById("updating-status").innerHTML = ''
	// 	}).buildRequirementTreeHtml();
	// }

	function filterFunction() {
		var input, filter, ul, li, a, i;

		// TODO: How to revert state after searching?
		// Make All Visible to Search
		divAll = document.getElementsByClassName('dropdown-content');
		for (i = 0; i < divAll.length; i++) {
			// If it is not showing
			if (!document.getElementById(divAll[i].id).classList.contains('show')) {
				// divAll[i].style.display = "block"
				document.getElementById(divAll[i].id).classList.add("show")
			}

		}

		input = document.getElementById("myInput");
		filter = input.value.toUpperCase();
		div = document.getElementsByClassName('reqSearcheableObj');
		for (i = 0; i < div.length; i++) {
			txtValue = div[i].textContent || div[i].innerText;
			if (txtValue.toUpperCase().indexOf(filter) > -1) {
				div[i].style.display = "";
				// document.getElementById(divAll[i].id).classList.toggle("show")
			} else {
				div[i].style.display = "none";
			}
		}

		// If Filter Empty, close all
		if (filter == "") {
			divAll = document.getElementsByClassName('dropdown-content')
			for (i = 0; i < divAll.length; i++) {
				if (document.getElementById(divAll[i].id).classList.contains('show')) {
					// divAll[i].style.display = "block"
					document.getElementById(divAll[i].id).classList.remove("show")
				}
			}
		}
	}

	// TODO: The listeners should be for the div, not for the LI
	// Once I separate the div and the Icont, they need to ahve different listeners, sicne they will have different actions

	function addTreeListener() {


		// var toggler = document.getElementsByClassName("caret");
		// var i;
		// for (i = 0; i < toggler.length; i++) {
		// 	toggler[i].addEventListener("click", function () {
		// 		this.parentElement.querySelector(".nested").classList.toggle("active");
		// 		this.classList.toggle("caret-down");

		// 	});
		// }

		// var valis = document.getElementsByClassName("vali");
		// for (i = 0; i < valis.length; i++) {
		// 	valis[i].addEventListener("click", function () {
		// 		google.script.run
		// 			.withFailureHandler(errorMessage)
		// 			.insertVali(this.id);
		// 	});
		// }

		// // Listener to Expand Icon
		var objects = document.querySelectorAll(".expand_icon, .truncated-text");
		for (i = 0; i < objects.length; i++) {
			// console.log('Added Listener on: '+ objects[i].id)
			objects[i].addEventListener("click", function () {
				// console.log('Clicked on to expand: children_' + this.parentElement.id)
				expandObjectChildren('children_' + this.parentElement.id)
			});
		}

		// Listener to Text Area
		var objects = document.querySelectorAll(".show-properties");
		for (i = 0; i < objects.length; i++) {
			objects[i].addEventListener("click", function () {
				// console.log("Clicked button");
				toggleObjectProperties(this.parentElement.id)
			});
		}

		// Listener to Plus Button - Add Element
		var objects = document.getElementsByClassName("add-element");
		for (i = 0; i < objects.length; i++) {
			objects[i].addEventListener("click", function () {
				document.getElementById("updating-status").innerHTML = 'Inserting Requirements...'
				// console.log('Clicked on Add Element for: ' + this.parentElement.id)

				var projectId = $("#options-projects").val();

				// TODO: Try checking INput to download only the necessary data; Maybe do it on google script
				var specifications = JSON.parse(document.getElementById(types.specifications.data).getAttribute('data'));
				var labels = JSON.parse(document.getElementById(types.labels.data).getAttribute('data'));
				var requirements = JSON.parse(document.getElementById(types.requirements.data).getAttribute('data'));
				var groups = JSON.parse(document.getElementById(types.groups.data).getAttribute('data'));
				var tags = JSON.parse(document.getElementById(types.tags.data).getAttribute('data'));
				var files = JSON.parse(document.getElementById(types.files.data).getAttribute('data'));

				// Order Requirements by Identifier - TODO: Function to Select what to order by

				var parent = this.parentElement.id.split("_");
				var parentType = parent[0].toString();
				var parentId = parseInt(parent[1]);

				var requirementsToInsert = requirements
					.filter(x => x['specification'] === parentId)
					.sort(function (a, b) {
						if (a.identifier == b.identifier)
							return 0;
						if (a.identifier < b.identifier)
							return -1;
						if (a.identifier > b.identifier)
							return 1;
					})

				var iteration = 0
				var maxIterations = 10
				var limitNumRows = 500
				// numberofReq = requirementsToInsert.length
				callInsertRequirement(projectId, parentId, requirementsToInsert, requirements, tags, groups, files)


				// Recursive Function to Insert Requirements
				function callInsertRequirement(projectId, parentId, requirementsToInsert, requirements, tags, groups, files, previousTableIndex = null) {
					// TODO: Avoid sending duplicated requirements; Instead of a Subset, I could pass the index only - requirementsToInsert and rrequirements
					// THis is needed when we are referencing to a requriement that is not in the subset (e.g. as a parent)
					subset = requirementsToInsert.slice(iteration * (limitNumRows), iteration * (limitNumRows) + limitNumRows)
					// console.log(requirementsToInsert.length)
					if (subset.length > 0) {
						google.script.run
							.withFailureHandler(function () { document.getElementById("updating-status").innerHTML = 'Error Inserting Part ' + iteration })
							.withSuccessHandler(function (previousTableIndex) {
								iteration++;
								if (iteration < maxIterations) {
									document.getElementById("updating-status").innerHTML = 'Inserting Requirements - Part: ' + (iteration + 1)
									callInsertRequirement(projectId, parentId, requirementsToInsert,requirements, tags, groups, files, previousTableIndex);
								}
							})
							.insertRequirementsInSpec_asTable_fromTemplate(projectId, parentId, subset, requirements, tags, groups, files, previousTableIndex);
					} else {
						document.getElementById("updating-status").innerHTML = '';
					}
				}

			});
		}


		// var labels = document.getElementsByClassName("label");
		// for (i = 0; i < labels.length; i++) {
		// 	labels[i].addEventListener("click", function () {
		// 		labelId = this.id;
		// 		google.script.run.withFailureHandler(errorMessage).direct_insert(labelId, 'name');
		// 	});
		// }

		// var specifications = document.getElementsByClassName("specification");
		// for (i = 0; i < specifications.length; i++) {
		// 	specifications[i].addEventListener("click", function () {
		// 		specId = this.id;
		// 		google.script.run.withFailureHandler(errorMessage).direct_insert(specId, 'name');
		// 	});
		// }

		// var groups = document.getElementsByClassName("group");
		// for (i = 0; i < groups.length; i++) {
		// 	groups[i].addEventListener("click", function () {
		// 		groupId = this.id;
		// 		google.script.run.withFailureHandler(errorMessage).direct_insert(groupId, 'name');
		// 	});
		// }



		// var properties = document.getElementsByClassName("property");
		// for (i = 0; i < properties.length; i++) {
		// 	properties[i].addEventListener("click", function () {
		// 		// console.log('Clicked on to element: ' + this.parentElement.id)
		// 		document.getElementById("updating-status").innerHTML = 'Inserting Element';
		// 		htmlElementId = this.id.split('_property_');
		// 		reqId = htmlElementId[0];
		// 		propertyName = htmlElementId[1];
		// 		var types = {
		// 			'label':"labelsData",
		// 			'specification': "specificationsData",
		// 			'group': "groupsData",
		// 			'requirement': "requirementsData"
		// 		}
		// 		for([key, key_dataId]  of Object.entries(types)){
		// 			if (this.parentElement.classList.contains(key)) {
		// 				var data = JSON.parse(document.getElementById(key_dataId).getAttribute('data'));
		// 				google.script.run.withFailureHandler(errorMessage).direct_insert(data, this.parentElement.id, propertyName);
		// 			}
		// 		}
		// 		// Reexpand after Insertion ( Workaround )
		// 		expandObjectChildren(this.parentElement.id)
		// 	});
		// }

		function errorMessage(error) {
			//Logger.log(error);
		}

	}



	function updateTree(id, name) {
		$('#projectTree').html("Loading tree " + name + "....");
		google.script.run.withSuccessHandler(
			function (newHtml) {
				$('#projectTree').html(newHtml);
				addTreeListener();
			}
		)
			.withFailureHandler(
				function (error) {
					$('#projectTree').html("Failed to load project tree. Please try again, if the problem persist contact support@valispace.com");
				})
			.getProjectTree(id);
	}



	function updateAllTrees(projectId, projectName) {
		$('#projectTree').html("Loading components for " + name + "....");
		$('#requirementTree').html("Loading requirements for " + name + "....");
		google.script.run
			.withSuccessHandler()
			.withFailureHandler(
				function (error) {
					$('#requirementTree').html("Failed to load requirements. Please try again, if the problem persist contact support@valispace.com");
				})
			.getRequirementTree(projectId);

	}





	function buildRequirementsTree_browser() {
		document.getElementById("updating-status").innerHTML = 'Building Tree...'

		// console.log('Building Requirement Tree')
		var labels = JSON.parse(document.getElementById(types.labels.data).getAttribute('data'));
		var specifications = JSON.parse(document.getElementById(types.specifications.data).getAttribute('data'));
		var groups = JSON.parse(document.getElementById(types.groups.data).getAttribute('data'));


		// HTML Initial
		var htmlToWrite = '<ul class="reqTreeMain">'

		// Root
		var labelsRoot = labels.filter(x => x['parent'] === null)
		var specificationsRoot = specifications.filter(x => x['labels'].length === 0)
		// TODO: Add labels and specifications to html


		function getSpecificationsAndGroups(parents) {

			for (index in parents) {
				var parent = parents[index]
				// console.log('parent', parent['name'])

				// If Parent is a Specification, it has "requirement_groups"
				if ("requirement_groups" in parent) {
					var parentId_html = types.specifications.name + '_'+ parent['id']

					// console.log('Adding Specification', parent['name'])
					htmlToWrite = htmlToWrite.concat('<li class="reqSearcheableObj specification" id="', parentId_html, '">', expandIcon, specificationIcon, '<div class="truncated-text">', String(parent['name']), '</div>', plusIcon, propertiesIcon, '</li>')
					// subHtml.concat(parent['name'])

					var parentId = parent['id']

					var groupsInside = groups.filter(x => x['specification'] === parentId & x['parent'] === null)

					htmlToWrite = htmlToWrite.concat('<div class="nested dropdown-content" id="children_', parentId_html, '">')
					getSpecificationsAndGroups(groupsInside)
					htmlToWrite = htmlToWrite.concat('</div>')
				}
				// If Parent is a Another Group, it has "children"
				if ("children" in parent) {
					var parentId_html = types.groups.name + '_' + parent['id']

					htmlToWrite = htmlToWrite.concat('<li class="reqSearcheableObj group" id="', parentId_html, '">', expandIcon, sectionIcon, '<div class="truncated-text">', String(parent['name']), '</div>', plusIcon, propertiesIcon,'</li>')
					// subHtml.concat(parent['name'])

					var parentId = parent['id']
					var groupsInside2 = groups.filter(x => x['parent'] === parentId)


					htmlToWrite = htmlToWrite.concat('<div class="nested dropdown-content" id="children_', parentId_html, '">')
					if (groupsInside2.length != 0) {
						getSpecificationsAndGroups(groupsInside2)
					}
					htmlToWrite = htmlToWrite.concat('</div>')
				}
			}
		}


		function getLabels(parents) {
			// subHtml = ''
			for (index in parents) {
				var parent = parents[index]
				var parentId_html = types.labels.name + '_' + parent['id']

				// Add to html
				htmlToWrite = htmlToWrite.concat('<li class="reqSearcheableObj label" id="', parentId_html, '">', expandIcon, folderIcon, '<div class="truncated-text">', String(parent['name']), '</div></li>')
				// subHtml.concat(parent['name'])
				// console.log(parent['name'])

				var labelsInside = labels.filter(x => x['parent'] === parent['id'])

				htmlToWrite = htmlToWrite.concat('<div class="nested dropdown-content" id="children_', parentId_html, '">')
				getLabels(labelsInside)

				var specsInside = specifications.filter(x => x['labels'][0] === parent['id'])

				for (index in specsInside) {
					var specification = specsInside[index]
					// htmlToWrite = htmlToWrite.concat('<div class="nested dropdown-content" id="children_', parentId_html, '">')
					getSpecificationsAndGroups([specification])
					// htmlToWrite = htmlToWrite.concat('</div>')

				}
				htmlToWrite = htmlToWrite.concat('</div>')
			}
			// console.log(subHtml)
		}



		// console.log('Building Label Roots')
		getLabels(labelsRoot)
		// console.log('Building SPecification Roots')
		getSpecificationsAndGroups(specificationsRoot)


		htmlToWrite = htmlToWrite.concat('</ul>')

		document.getElementById("updating-status").innerHTML = ''
		// console.log('Done Building')

		document.getElementById('requirementTreeInsertButton').innerHTML = htmlToWrite;
		document.getElementById("updating-status").innerHTML = ''
	}

	function getRequirements() {
		var requirements = JSON.parse(document.getElementById("requirementsData").getAttribute('data'));
		for (index in requirements) {
			var requirement = requirements[index]
			// console.log(requirement['identifier'])

			displayName = requirement['identifier'] + " " + requirement['title']
			var reqName = types.requirements.name+'_'+requirement['id']
			// If Not in a Group ['group'] = null, it is in a specificaiton only
			if (requirement['group'] == null) {
				var parentId = 'children_'+types.specifications.name + '_' + requirement['specification'].toString()
				// console.log(parentId)
				var htmlToWrite = document.getElementById(parentId).innerHTML
				htmlToWrite = htmlToWrite.concat('<li class="reqSearcheableObj requirement" id="', reqName, '">', reqIcon, '<div class="truncated-text">', displayName, '</div>', propertiesIcon);

				document.getElementById(parentId).innerHTML = htmlToWrite
			} else {
				var parentId = 'children_'+types.groups.name + '_' + requirement['group'].toString()
				// console.log(parentId)
				var htmlToWrite = document.getElementById(parentId).innerHTML
				htmlToWrite = htmlToWrite.concat('<li class="reqSearcheableObj requirement" id="', reqName, '">', reqIcon, '<div class="truncated-text">', displayName, '</div>', propertiesIcon);

				document.getElementById(parentId).innerHTML = htmlToWrite
			}

		}
	}
	// function addRequirementsFromSpecToTree(requirements){
	// 	this.parentElement.id

	// 	var requirementsToInser = requirements.filter(x => x['specification'] === parentId)

	// }

	// function insertTest123() {
	// 	console.log('Trying to insert Requirements')
	// 	spec_id = 52241

	// 	var requirementsString = document.getElementById('requirementsData').getAttribute('data');
	// 	var requirements = JSON.parse(requirementsString);

	// 	console.log(requirements)
	// 	google.script.run.
	// 		withFailureHandler('failed!')
	// 		.withSuccessHandler(console.log('inserted!'))
	// 		.insertRequirementsInSpec_asTable2(spec_id, requirements)
	// }

</script>